# -*- coding: utf-8 -*-
"""new for motor(last code).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1onb_RI3dm8NnETNc4KSrF0Ofp51pqhF4
"""

pip install git+https://github.com/logictensornetworks/logictensornetworks.git

!pip install --upgrade git+https://github.com/logictensornetworks/logictensornetworks.git

import ltn
print(dir(ltn))

import numpy as np
import pandas as pd
import seaborn as sns
import shap
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from sklearn.model_selection import train_test_split
import ltn
import tensorflow as tf

# Load the dataset
feeds_df = pd.read_csv("feeds2.csv")

print(feeds_df.columns)

# Data preprocessing
feeds_df.dropna(inplace=True)
feeds_df['rotational_speed'] = feeds_df['rotational_speed'].apply(lambda x: min(x, 250))  # Scaling rotational speed
feeds_df['air_temperature'] = (feeds_df['air_temperature'] - feeds_df['air_temperature'].min()) / \
                              (feeds_df['air_temperature'].max() - feeds_df['air_temperature'].min()) * 50  # Scaling air temperature up to 50
X = feeds_df[['temperature', 'humidity', 'vibration', 'rotational_speed', 'air_temperature']]

# Symbolic Injection (Defining domain knowledge rules)
def rule_vibration(vibration):
    return vibration < 1  # Stricter threshold for bad motor

def rule_temperature(temperature):
    return temperature < 65  # Lower the threshold to classify as good

# Apply rules to dataset
feeds_df['rule_vibration'] = feeds_df['vibration'].apply(rule_vibration)
feeds_df['rule_temperature'] = feeds_df['temperature'].apply(rule_temperature)

# Combine rules to create labels
y = (feeds_df['rule_vibration'] & feeds_df['rule_temperature']).astype(int)  # Convert to binary labels

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# LTN adaptation
motor_good = ltn.Predicate(
    tf.keras.Sequential([
        tf.keras.layers.Dense(10, activation="relu", input_shape=(1,)),
        tf.keras.layers.Dense(1, activation="sigmoid")
    ])
)

vib = ltn.Variable("vib", X[['vibration']].values)
temp = ltn.Variable("temp", X[['temperature']].values)
speed = ltn.Variable("speed", X[['rotational_speed']].values)

import ltn

# Check available attributes within ltn.fuzzy_ops
print(dir(ltn.fuzzy_ops))

import ltn
import tensorflow as tf
import numpy as np

# ... (other function definitions)

from ltn.core import Formula

# Define a custom function to apply Implies_Reichenbach
def apply_implies(operand1, operand2):
    # Cast operands to float tensors for compatibility
    operand1_tensor = tf.cast(operand1.tensor, tf.float32)
    operand2_tensor = tf.cast(operand2.tensor, tf.float32)

    # Apply Implies_Reichenbach to the tensors
    result_tensor = ltn.fuzzy_ops.Implies_Reichenbach()(operand1_tensor, operand2_tensor)

    # Create a new Formula from the result tensor
    # Using set union for free_vars:
    result_formula = Formula(result_tensor, free_vars=set(operand1.free_vars).union(set(operand2.free_vars)))

    return result_formula

# Custom function to apply And_Min to a list of formulas
def apply_and_min(formulas):
    result = formulas[0].tensor  # Initialize with the tensor of the first formula
    for formula in formulas[1:]:
        # Apply And_Min to the tensors of the formulas
        result = ltn.fuzzy_ops.And_Min()(result, formula.tensor) # Applying the fix
    # Wrap the final result back into a Formula object

    result_formula = Formula(result, free_vars=formulas[0].free_vars)
    return result_formula


def custom_aggregator(formula):
    return tf.reduce_mean(formula.tensor)

# Create an LTN Variable for humidity
humidity = ltn.Variable("humidity", X[['humidity']].values) # Define humidity similar to vib and temp

# Construct the formula using And_Min or And_Prod
formula_body = apply_and_min([
    apply_implies(motor_good(vib), motor_good(temp)),
    apply_implies(motor_good(vib), motor_good(speed)),
    apply_implies(motor_good(vib), motor_good(humidity))

])

# Apply custom aggregation
formula = custom_aggregator(formula_body)

print(formula.numpy())

# Train a machine learning model
clf = RandomForestClassifier(n_estimators=100, criterion='entropy', random_state=42)
clf.fit(X_train, y_train)

# Predictions
y_pred = clf.predict(X_test)

# Evaluation
conf_mat = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:\n", conf_mat)
print("Classification Report:\n", classification_report(y_test, y_pred))

explainer = shap.Explainer(clf, X_train)
shap_values = explainer(X_test[:200])  # Ensure full dataset is used
print(shap_values.shape)  # Check the shape, it should be (number_of_samples, number_of_features)

# Assuming your target variable has two classes, you might need to specify the class index:
shap.summary_plot(shap_values.values[:,:,1], X_test[:200], feature_names=X_test.columns) # if you want to plot for class 1
# or
# shap.summary_plot(shap_values.values[:,:,0], X_test[:200], feature_names=X_test.columns) # if you want to plot for class 0

# Function for making predictions
def predict_motor_status(temp, humidity, vib, speed, air_temp):
    test_input = np.array([[temp, humidity, vib, speed, air_temp]])
    prediction = clf.predict(test_input)
    return "Motor is GOOD" if prediction == 1 else "Motor is BAD"

# Example usage
print(predict_motor_status(30.4, 41, 0, 200, 30))  # Example of a GOOD motor
print(predict_motor_status(65, 41, 1, 250, 50))  # Example of a BAD motor

"""temperature, humidity, vibartion, rotational_
speed, air_temperature
"""

import joblib

# Train your model (you already did this)
clf = RandomForestClassifier(n_estimators=100, criterion='entropy', random_state=42)
clf.fit(X_train, y_train)

# Save the trained model to a file
joblib.dump(clf, "motor_health_model.pkl")